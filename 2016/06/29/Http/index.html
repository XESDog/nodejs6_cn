<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Nodejs6_API_CN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="title:Http#Http使用Http,必须通过require(&amp;#39;http)。
Http接口在Node.js中被设计成支持多功能协议,这些协议是以前很难以使用的。特别是大的消息数据,该接口非常小心,从不缓冲请求和恢复————用户能够处理数据流。
Http头信息通过对象的形式呈现如下:
12345&amp;#123; &amp;apos;content-length&amp;apos;: &amp;apos;123&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="Nodejs6_API_CN">
<meta property="og:url" content="http://xesjiaoyan.github.io/nodejs6_cn/2016/06/29/Http/index.html">
<meta property="og:site_name" content="Nodejs6_API_CN">
<meta property="og:description" content="title:Http#Http使用Http,必须通过require(&amp;#39;http)。
Http接口在Node.js中被设计成支持多功能协议,这些协议是以前很难以使用的。特别是大的消息数据,该接口非常小心,从不缓冲请求和恢复————用户能够处理数据流。
Http头信息通过对象的形式呈现如下:
12345&amp;#123; &amp;apos;content-length&amp;apos;: &amp;apos;123&amp;">
<meta property="og:updated_time" content="2016-06-29T03:12:58.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nodejs6_API_CN">
<meta name="twitter:description" content="title:Http#Http使用Http,必须通过require(&amp;#39;http)。
Http接口在Node.js中被设计成支持多功能协议,这些协议是以前很难以使用的。特别是大的消息数据,该接口非常小心,从不缓冲请求和恢复————用户能够处理数据流。
Http头信息通过对象的形式呈现如下:
12345&amp;#123; &amp;apos;content-length&amp;apos;: &amp;apos;123&amp;">
  
    <link rel="alternate" href="/atom.xml" title="Nodejs6_API_CN" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/nodejs6_cn/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/nodejs6_cn/" id="logo">Nodejs6_API_CN</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/nodejs6_cn/">Home</a>
        
          <a class="main-nav-link" href="/nodejs6_cn/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xesjiaoyan.github.io/nodejs6_cn"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Http" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/nodejs6_cn/2016/06/29/Http/" class="article-date">
  <time datetime="2016-06-29T03:12:58.000Z" itemprop="datePublished">2016-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h2 id="title-Http"><a href="#title-Http" class="headerlink" title="title:Http"></a>title:Http</h2><p>#Http<br>使用Http,必须通过<code>require(&#39;http)</code>。</p>
<p>Http接口在Node.js中被设计成支持多功能协议,这些协议是以前很难以使用的。<br>特别是大的消息数据,该接口非常小心,从不缓冲请求和恢复————用户能够处理数据流。</p>
<p>Http头信息通过对象的形式呈现如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123; &apos;content-length&apos;: &apos;123&apos;,</div><div class="line">  &apos;content-type&apos;: &apos;text/plain&apos;,</div><div class="line">  &apos;connection&apos;: &apos;keep-alive&apos;,</div><div class="line">  &apos;host&apos;: &apos;mysite.com&apos;,</div><div class="line">  &apos;accept&apos;: &apos;*/*&apos; &#125;</div></pre></td></tr></table></figure>
<p>key都是小写,value未被修改。(嘛意思?)</p>
<p>为了能够尽可能多的支持跟多的特性,Node.js的Http API是非常底层的。仅仅处理流和信息解析。<br>它解析消息到headers和body中,但是,它不解析实际的headers或body。</p>
<p>我们接收到的未处理的headers,被存在<code>rawHeaders</code>属性里面,格式<code>[key,value,key2,value2,...]</code>。<br>比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[ &apos;ConTent-Length&apos;, &apos;123456&apos;,</div><div class="line">  &apos;content-LENGTH&apos;, &apos;123&apos;,</div><div class="line">  &apos;content-type&apos;, &apos;text/plain&apos;,</div><div class="line">  &apos;CONNECTION&apos;, &apos;keep-alive&apos;,</div><div class="line">  &apos;Host&apos;, &apos;mysite.com&apos;,</div><div class="line">  &apos;accepT&apos;, &apos;*/*&apos; ]</div></pre></td></tr></table></figure>
<p>##http.Agent类</p>
<p>Http Agent被用来管理Http客户端请求的socket。</p>
<p>默认情况下Http Agent使用Connection:keep-alive。如果socket处于空闲状态,socket就会被关闭。<br>意思是说,Node.js对象池在keep-alive情况下好处多多,即使负载的情况下,也不用开发者通过手动来关闭Http clients。</p>
<p>如果你选择使用HTTP keepAlive,你能够创建一个Agent对象,并设置<code>flag</code>为<code>true</code>,该Agent对象保持未使用的socket在对象池中,<br>这将明确标记不保持Node.js进程运行。不管怎么样,当你不再使用它的时候明确的<code>destroy()</code>是非常好的选择,这时Socket将被关闭。</p>
<p>当socket发送<code>close</code>事件或<code>agentRemove</code>事件Socket将从agent的对象池中移除。<br>也就是说,如果你想保持一个Http请求处于open状态一段时间,并且,不希望该请求待在对象池中,你可以按照下面的做法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">http.get(options, (res) =&gt; &#123;</div><div class="line">  // Do stuff</div><div class="line">&#125;).on(&apos;socket&apos;, (socket) =&gt; &#123;</div><div class="line">  socket.emit(&apos;agentRemove&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>或者,你可以选择设置<code>agent:false</code>来使对象不会被存储到对象池。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">http.get(&#123;</div><div class="line">  hostname: &apos;localhost&apos;,</div><div class="line">  port: 80,</div><div class="line">  path: &apos;/&apos;,</div><div class="line">  agent: false  // create a new agent just for this one request</div><div class="line">&#125;, (res) =&gt; &#123;</div><div class="line">  // Do stuff with response</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="new-Agent-options"><a href="#new-Agent-options" class="headerlink" title="new Agent([options])"></a>new Agent([options])</h3><ul>
<li><p><code>options</code> \<object\> 设置agent的可配置选项:</object\></p>
<ul>
<li><code>keepAlive</code> \<boolean\> 保持socket在对象池中,以便未来被其他请求使用,Default=false。</boolean\></li>
<li><code>keepAliveMsecs</code> \<integer\> 当使用HTTP KeepAlive,会经常发送TCP KeepAlive数据包来保持活动状态,Default=1000,仅在<code>keepAlive</code><br>设置为<code>true</code>时有用。</integer\></li>
<li><code>maxSockets</code> \<number\> 每台主机允许socket的最大数量。Default=Infinity。</number\></li>
<li><code>maxFressSockets</code> \<number\> 自由状态下打开的socket最大数量,仅<code>keepAlive</code>设置为<code>true</code>时有用。</number\></li>
</ul>
</li>
</ul>
<p>http.globalAgent用来设置http.request()的默认值。<br>想要配置他们,你必须创建你自己的http.Agent对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const http = require(&apos;http&apos;);</div><div class="line">var keepAliveAgent = new http.Agent(&#123; keepAlive: true &#125;);</div><div class="line">options.agent = keepAliveAgent;</div><div class="line">http.request(options, onResponseCallback);</div></pre></td></tr></table></figure>
<h3 id="agent-createConnection-options-callback"><a href="#agent-createConnection-options-callback" class="headerlink" title="agent.createConnection(options[, callback])"></a>agent.createConnection(options[, callback])</h3><p>使用Http请求来生成一个socket/stream。</p>
<p>默认情况下,该方法和<code>net.createConnection()</code>是一样的,通常考虑灵活性一般会使用Agent来重写该方法。</p>
<p>一个socket/stream可以通过两种方法获得:通过该方法返回,或传递socket/stream给<code>callback</code>。</p>
<p><code>callback</code>签名:<code>(err,stream)</code>。</p>
<h3 id="agent-destroy"><a href="#agent-destroy" class="headerlink" title="agent.destroy()"></a>agent.destroy()</h3><p>通过agent销毁当前正使用的socket。</p>
<p>通常不必这么做,如果你正在使用agent且KeepAlive=true,当你知道agent不再被使用时,你最好明确的关闭它。否则,服务器结束它们之前,socket将会挂起很长一段时间。</p>
<h3 id="agent-freeSockets"><a href="#agent-freeSockets" class="headerlink" title="agent.freeSockets"></a>agent.freeSockets</h3><p>当HTTPKeepAlive被使用,一个包含socket数组的对象正等在Agent使用。不可修改。</p>
<h3 id="agent-getName-options"><a href="#agent-getName-options" class="headerlink" title="agent.getName(options)"></a>agent.getName(options)</h3><p>获取一组<code>options</code>表示的唯一name,来决定是否连接被重用。在http agent中,返回<code>host:post:localAddress</code>。<br>在http agent中, CA,cert,ciphers,以及其他HTTPS/TLS-specific选项决定socket的可重用性。</p>
<p>Options:</p>
<ul>
<li><code>host</code>: 请求到某服务器的域名和IP地址</li>
<li><code>port</code>: 远程服务器的端口号</li>
<li><code>localAddress</code>: 当请求发送的时候,绑定到网络连接的本地接口</li>
</ul>
<h3 id="agent-maxFreeSockets"><a href="#agent-maxFreeSockets" class="headerlink" title="agent.maxFreeSockets"></a>agent.maxFreeSockets</h3><p>默认设置为256,Agent支持HTTPKeepAlive时,将该值设置为自由状态下能够打开的最大值。</p>
<h3 id="agent-maxSockets"><a href="#agent-maxSockets" class="headerlink" title="agent.maxSockets"></a>agent.maxSockets</h3><p>默认情况下为无限。能同时开多少socket取决于服务器。</p>
<h3 id="agent-requests"><a href="#agent-requests" class="headerlink" title="agent.requests"></a>agent.requests</h3><p>一个还未被分配到socket的请求队列,不可修改。</p>
<h3 id="agent-sockets"><a href="#agent-sockets" class="headerlink" title="agent.sockets"></a>agent.sockets</h3><p>一个当前被agent使用的socket数组,不可修改。</p>
<h2 id="http-ClientRequest-类"><a href="#http-ClientRequest-类" class="headerlink" title="http.ClientRequest 类"></a>http.ClientRequest 类</h2><p>该对象通过<code>http.request()</code>内部创建并返回。它表示一个header已经进入队列了的正在进行的请求。<br>这个header依然可以通过 <code>setHeader(name,value)</code>,<code>getHeader(name)</code>,<code>removeHeader(name)</code>来做修改。<br>真是的header将沿着第一个数据块,或者链接关闭的时候发送。</p>
<p>要想获取response,添加request对象的<code>response</code>侦听事件。<code>response</code>事件将在response头信息被收到的时候通过request对象发送。<br><code>response</code>事件被执行的<code>`时候带一个</code>http.IncomingMessage`类型的参数。</p>
<p>在<code>response</code>事件期间,你可以为response对象添加侦听事件,特别是<code>data</code>事件。</p>
<p>如果你侦听了<code>response</code>事件,你必须将response对象的数据完全取出。你可以通过 <code>response.read()</code>当触发<code>readable</code>事件的时候。<br>你还可以添加 <code>data</code>处理函数,也可以执行<code>.resume()</code>方法。知道所有数据都被取出,执行<code>end</code>事件。如果有数据没有读取完,将导致内存出错。</p>
<p>注意:Node.js不会去检测是否Content-Length以及被发送的body的长度是否相等。</p>
<p>###Event:’abort’<br><code>function (){}</code><br>当请求被客户端忽略的时候发送。该事件仅仅在第一次call abort()的时候发送。</p>
<p>###Event:’checkExpectation’<br><code>function (request,response){}</code><br>每次发送一个请求,都有一个Expect头被收到。如果该事件未被侦听,服务端将自动回复一个417 Expectation Failed。</p>
<p>注意,当这个事件被发送并被处理,<code>request</code>事件将不会发送。</p>
<p>###Event:’connect’<br><code>function (response,socket,head){}</code><br>每次服务端回复一个请求的时候都会发送一个<code>CONNECT</code>事件。如果这个事件没有被侦听,客户接收<code>CONNECT</code>事件时,他们的连接就已经关闭了。</p>
<p>以下例子告诉你如何侦听<code>connenct</code>事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">const http = require(&apos;http&apos;);</div><div class="line">const net = require(&apos;net&apos;);</div><div class="line">const url = require(&apos;url&apos;);</div><div class="line"></div><div class="line">// Create an HTTP tunneling proxy</div><div class="line">var proxy = http.createServer( (req, res) =&gt; &#123;</div><div class="line">  res.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;);</div><div class="line">  res.end(&apos;okay&apos;);</div><div class="line">&#125;);</div><div class="line">proxy.on(&apos;connect&apos;, (req, cltSocket, head) =&gt; &#123;</div><div class="line">  // connect to an origin server</div><div class="line">  var srvUrl = url.parse(`http://$&#123;req.url&#125;`);</div><div class="line">  var srvSocket = net.connect(srvUrl.port, srvUrl.hostname, () =&gt; &#123;</div><div class="line">    cltSocket.write(&apos;HTTP/1.1 200 Connection Established\r\n&apos; +</div><div class="line">                    &apos;Proxy-agent: Node.js-Proxy\r\n&apos; +</div><div class="line">                    &apos;\r\n&apos;);</div><div class="line">    srvSocket.write(head);</div><div class="line">    srvSocket.pipe(cltSocket);</div><div class="line">    cltSocket.pipe(srvSocket);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// now that proxy is running</div><div class="line">proxy.listen(1337, &apos;127.0.0.1&apos;, () =&gt; &#123;</div><div class="line"></div><div class="line">  // make a request to a tunneling proxy</div><div class="line">  var options = &#123;</div><div class="line">    port: 1337,</div><div class="line">    hostname: &apos;127.0.0.1&apos;,</div><div class="line">    method: &apos;CONNECT&apos;,</div><div class="line">    path: &apos;www.google.com:80&apos;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  var req = http.request(options);</div><div class="line">  req.end();</div><div class="line"></div><div class="line">  req.on(&apos;connect&apos;, (res, socket, head) =&gt; &#123;</div><div class="line">    console.log(&apos;got connected!&apos;);</div><div class="line"></div><div class="line">    // make a request over an HTTP tunnel</div><div class="line">    socket.write(&apos;GET / HTTP/1.1\r\n&apos; +</div><div class="line">                 &apos;Host: www.google.com:80\r\n&apos; +</div><div class="line">                 &apos;Connection: close\r\n&apos; +</div><div class="line">                 &apos;\r\n&apos;);</div><div class="line">    socket.on(&apos;data&apos;, (chunk) =&gt; &#123;</div><div class="line">      console.log(chunk.toString());</div><div class="line">    &#125;);</div><div class="line">    socket.on(&apos;end&apos;, () =&gt; &#123;</div><div class="line">      proxy.close();</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="Event-’continue’"><a href="#Event-’continue’" class="headerlink" title="Event:’continue’"></a>Event:’continue’</h3><p><code>function(){}</code><br>当服务端发送了一个’100 continue’Http回复的时候触发该事件,通常是因为request包含’Expect:100-continue’。这是一条客户端request body中的指令。</p>
<h3 id="Event-’response’"><a href="#Event-’response’" class="headerlink" title="Event:’response’"></a>Event:’response’</h3><p><code>function (response){}</code><br>当回复被request收到的时候触发。该事件仅触发一次。<code>response</code>参数是一个<code>http.IncomingMessage</code>对象。</p>
<h3 id="Event-’socket’"><a href="#Event-’socket’" class="headerlink" title="Event:’socket’"></a>Event:’socket’</h3><p><code>function (socket){}</code><br>一个socket分配给request之后触发。</p>
<p>###Event:’upgrade’<br><code>function (response,socket,head){}</code><br>服务端有更新回复request的时候触发。如果该事件未被侦听,客户端收到更新事件头信息的时候连接就关闭了。</p>
<p>下面代码展示如何侦听<code>upgrade</code>事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">const http = require(&apos;http&apos;);</div><div class="line"></div><div class="line">// Create an HTTP server</div><div class="line">var srv = http.createServer( (req, res) =&gt; &#123;</div><div class="line">  res.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;);</div><div class="line">  res.end(&apos;okay&apos;);</div><div class="line">&#125;);</div><div class="line">srv.on(&apos;upgrade&apos;, (req, socket, head) =&gt; &#123;</div><div class="line">  socket.write(&apos;HTTP/1.1 101 Web Socket Protocol Handshake\r\n&apos; +</div><div class="line">               &apos;Upgrade: WebSocket\r\n&apos; +</div><div class="line">               &apos;Connection: Upgrade\r\n&apos; +</div><div class="line">               &apos;\r\n&apos;);</div><div class="line"></div><div class="line">  socket.pipe(socket); // echo back</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// now that server is running</div><div class="line">srv.listen(1337, &apos;127.0.0.1&apos;, () =&gt; &#123;</div><div class="line"></div><div class="line">  // make a request</div><div class="line">  var options = &#123;</div><div class="line">    port: 1337,</div><div class="line">    hostname: &apos;127.0.0.1&apos;,</div><div class="line">    headers: &#123;</div><div class="line">      &apos;Connection&apos;: &apos;Upgrade&apos;,</div><div class="line">      &apos;Upgrade&apos;: &apos;websocket&apos;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  var req = http.request(options);</div><div class="line">  req.end();</div><div class="line"></div><div class="line">  req.on(&apos;upgrade&apos;, (res, socket, upgradeHead) =&gt; &#123;</div><div class="line">    console.log(&apos;got upgraded!&apos;);</div><div class="line">    socket.end();</div><div class="line">    process.exit(0);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>###request.abort()<br>标记request终止中。执行该方法将导致response中剩下的数据被丢弃,并且,socket被销毁。</p>
<p>###request.end([data][,encoding][,callback])<br>结束正在发送的请求,还有任何部分的数据没有发送,都将缓冲到stream中。如果request被分割成块了,将发送<code>0\r\n\r\n</code>来表示终结。</p>
<p>如果<code>data</code>被指定,则相当于调用<code>response.write(data,encoding)</code>,再执行<code>request.end(callback)</code>。</p>
<p>如果<code>callback</code>被指定,当request流被结束之后执行。</p>
<p>###request.flushHeaders()<br>flush request头信息<br>考虑到效率问题,Node.js通常缓存request头信息,知道<code>request.end()</code>,或者写入第一块请求数据。它试图打包request头信息和数据到一个独立的TCP包中。</p>
<p>通常你希望能够将数据保持在一个TCP请求的来回期间,可是一般在晚一些的时间,第一次数据才会被发送到。<code>request.flushHeaders()</code>让你避开了优化启动请求。</p>
<p>###request.setNoDelay([noDelay])<br>当一个socket被分配到某个request并断开的时候,将执行<code>socket.setNoDelay()</code>。</p>
<p>###request.setSocketKeepALive([enable][,initialDelay])<br>当一个socket被分配到某个request并断开的时候,将执行<code>socket.setKeepAlive()</code>。</p>
<p>###request.setTimeout(timeout[,callback])<br>当一个socket被分配到某个request并断开的时候,将执行<code>socket.setTimeout()</code>。</p>
<ul>
<li><code>timeout</code>\<number\> 一个请求被超时xxx毫秒。</number\></li>
<li><code>callback</code>\<function\> 当超时指定的时间到了之后执行的方法。相当于绑定<code>timeout</code>事件。</function\></li>
</ul>
<p>###request.write(chunk[,encoding][,callback])<br>发送数据,调用这个方法的时候,用户能够直接控制请求中的数据。也就是说,当创建这种请求的时候,用户可能正在使用<code>[Transter-Encoding,&#39;chunked&#39;]</code>头信息。</p>
<p><code>chunk</code>参数必须是<code>Buffer</code>对象或者一个string。</p>
<p><code>encoding</code>参数仅当<code>chunk</code>是string的情况下可选,默认为<code>utf8</code>。</p>
<p><code>callback</code>参数可选,当大块数据被flush的时候调用。</p>
<p>返回<code>reqeust</code>。</p>
<p>##http.Server类</p>
<p>继承至<code>net.Server</code>类,并且增加额外的事件:</p>
<p>###Event:’checkContinue’<br><code>function(request,response){}</code><br>Expect:100-continue 被接收到的时候发送一个请求。如果没有侦听该事件,服务端将酌情自动回复100 Continue。</p>
<p>如果客户端继续发送request body部分,那么处理事件的同时调用<code>response.writeContinue()</code>。如果客户端不继续发送request body部分,那么生成一个恰当的HTTP恢复(e.g.,400 Bad Request)</p>
<p>注意:当该事件被触发并处理,<code>request</code>事件将不被触发。</p>
<p>###Event:’clientError’<br><code>function(exception,socket){}</code></p>
<p>如果客户端触发<code>error</code>事件,它将在这里被转发。侦听器负责关闭或销毁底层socket。比如,你希望通过更加优雅的方式关闭socket,给用户返回一个<code>400 Bad Request</code>,而不是突然关闭。</p>
<p>默认,当遇到异常请求会立即销毁socket。</p>
<p>错误来源于<code>socket</code>,是一个<code>net.Socket</code>对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const http = require(&apos;http&apos;);</div><div class="line"></div><div class="line">const server = http.createServer((req, res) =&gt; &#123;</div><div class="line">  res.end();</div><div class="line">&#125;);</div><div class="line">server.on(&apos;clientError&apos;, (err, socket) =&gt; &#123;</div><div class="line">  socket.end(&apos;HTTP/1.1 400 Bad Request\r\n\r\n&apos;);</div><div class="line">&#125;);</div><div class="line">server.listen(8000);</div></pre></td></tr></table></figure></p>
<p>当<code>clientError</code>事件发生,回调函数中不会有<code>request</code>和<code>response</code>对象,因此所有Http响应请求,包括响应头和有效载荷,必须直接的写入<code>socket</code>对象。<br>必须确保按照正确的格式来响应信息。</p>
<p>###Event:’close’</p>
<p><code>function (){}</code></p>
<p>当服务端<code>close</code>的时候触发。</p>
<p>###Event:’connect’<br><code>function (request,socket,head){}</code></p>
<p>一个客户端请求一个http <code>CONNECT</code>方法时发送,如果事件未被侦听,当客户端请求<code>CONNECT</code>方法的时候讲关闭该链接。</p>
<ul>
<li><code>request</code> http请求参数,就像在request事件中一样。</li>
<li><code>socket</code>  客户端和服务端之间的socket链接。</li>
<li><code>head</code>    Buffer的一个实例,数据流的第一个包,有可能为空。</li>
</ul>
<p>事件发送之后,request’s socket不会存在<code>data</code>事件处理,也就是说,你需要绑定处理函数,来处理通过socket发送到服务端的数据。</p>
<p>###Event:’connection’<br><code>function (socket){}</code></p>
<p>当新的TCP流被建立,通常用户不需要处理该事件。特别的,协议解析器绑定socket时采用的方式使得socket不会发送<code>readable</code>事件。socket也可以在<code>request.connection</code>中被访问。</p>
<p>###Event:’request’<br><code>function (request,response){}</code></p>
<p>每次请求都会触发事件。注意,每个链接都可能有大量的请求(在keep-alive链接的情况下)。<code>request</code>是<code>http.IncomingMessage</code>实例,<code>response</code>是<code>http.ServerResponse</code>实例。</p>
<p>###Event:’upgrade’</p>
<p><code>function (request,socket,head){}</code></p>
<p>每次客户端请求一个http upgrade的时候触发。如果该事件未被侦听,客户端请求upgrade的时候就会被关闭。</p>
<ul>
<li><code>request</code> http request 参数,就像request事件中一样。</li>
<li><code>socket</code>  服务端和客户端之间的socket链接</li>
<li><code>head</code>    Buffer实例,upgrade流中的第一个包,可能为空。</li>
</ul>
<p>事件发送之后,request’s socket不会存在<code>data</code>事件处理,也就是说,你需要绑定处理函数,来处理通过socket发送到服务端的数据。</p>
<p>###server.close([callback])<br>停止接受新的连接,查看 <code>net.Server.close()</code></p>
<p>###server.listen(handle,[,callback])</p>
<ul>
<li><code>handle</code> \<object\></object\></li>
<li><code>callback</code> \<function\></function\></li>
</ul>
<p><code>handle</code>能够被设置为一个<code>server</code>或<code>socket</code>对象。<br>这将导致server在指定的handle上接受一个连接,但是,它被假设该文件描述符或handle已经被绑定到一个端口或者域socket。</p>
<p>侦听文件描述符在windows中不被支持。</p>
<p>该方法是一步的,最后的参数callback将被作为一个侦听器添加到<code>listening</code>事件。see <code>net.Server.listen()</code>。</p>
<p>返回 <code>server</code>。</p>
<p>###server.listen(path,[,callback])<br>为给出的<code>path</code>上建立的连接启动一个UNIX socket server 侦听。</p>
<p>该方法是一步的。最后的参数callback将被作为一个侦听器添加到<code>listenling</code>事件。see <code>net.Server.listen(path)</code>。</p>
<p>###server.listen(port[,hostname][,backlog][,callback])<br>在指定的port,hostname上开始接收连接。如果hostname被忽略,且IPv6可用的时候,服务器将接受任何IPv6地址(<code>::</code>)的连接,<br>或者除开IPv4地址(<code>0.0.0.0</code>)的任何连接。port值如果为0,则随机分配一个端口号。</p>
<p>侦听一个UNIX socket,提供一个filename而不是端口号和主机名。</p>
<p>Backlog是排列等待连接的极限长度,实际长度由系统决定,在linux中则通过<code>tcp_max_syn_backlog</code>和<code>somaxconn</code>决定。<br>默认值是511(不是512)</p>
<p>该方法是一步的,最后的参数callback将被作为一个侦听器添加到<code>listenling</code>事件。see <code>net.Server.listen(port)</code>。</p>
<p>###server.listening<br>一个布尔值,表示是否服务器处于侦听状态。</p>
<p>###server.maxHeadersCount<br>最大的传入header的数量,默认等于1000,如果设置为0,则被设置为无限。</p>
<p>###server.setTimeout(msecs,callback)</p>
<ul>
<li><code>msecs</code> \<number></number></li>
<li><code>callback</code> \<function></function></li>
</ul>
<p>设置socket超时的值。如果超时发生,通过server对象发送<code>timeout</code>事件,将socket作为参数传递。</p>
<p>默认,server超时值为2分钟,如果曹氏,socket将被销毁。无论如何,如果你分配给server一个超时事件,那么你需要自己负责处理好超时事件。</p>
<p>返回server。</p>
<p>###server.timeout</p>
<ul>
<li>\<number> 默认=120000(2分钟)<br>socket超时未发生的时候,该值是不变的。</number></li>
</ul>
<p>注意,socket的逻辑是在连接的时候设置的。因此,修改这个值仅能影响新的server连接,不会对已经存在的连接产生任何影响。</p>
<p>设置为0将在禁止任何种类的超时行为。</p>
<p>##http.ServerResponse类</p>
<p>该对象通过HTTP server在内部创建——不是通过用户创建的。它被当成第二个参数传递到<code>request</code>事件中。</p>
<p>response实现但不继承Writable Stream接口。</p>
<p>###Event:’close’<br><code>function(){}</code><br>表明底层连接被在response.end()被执行之前被中断,或者能够flush。</p>
<p>###Event:’finish’<br><code>function(){}</code><br>response被发送的时候触发。更具体的说,该事件在最后一段head和body被移交到操作系统做网络传输的时候触发。<br>这并不表示客户端移交收到什么了。</p>
<p>该事件之后,跟多的事件将通过response对象发送。</p>
<p>###response.addTrailer(header)</p>
<p>该方法为response添加HTTP头信息的尾部</p>
<p>trailer在response中仅用作块编码。如果不是,它将默默的被丢弃。</p>
<p>注意,trailer部分会跟header信息的其他值一起发送,你不必单独对他做什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">response.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos;,</div><div class="line">                          &apos;Trailer&apos;: &apos;Content-MD5&apos; &#125;);</div><div class="line">response.write(fileData);</div><div class="line">response.addTrailers(&#123;&apos;Content-MD5&apos;: &apos;7895bf4b8828b55ceaf47747b4bca667&apos;&#125;);</div><div class="line">response.end();</div></pre></td></tr></table></figure>
<p>试图设置一个包含无效字符的header属性的名称或值返回<code>TypeError</code>异常。</p>
<p>###response.end([data][,encoding][,callback])</p>
<p>向服务端发出信号,response的header和body已经被发送。server应该考虑完成的情况<br>response.end()必须在每次回复的时候发送。</p>
<p>if <code>data</code> 被指定,其实相当于先调用response.write(data,encoding),然后执行 response.end(callback)</p>
<p>if  <code>callback</code>被指定,它将在response stream完成的时候执行。</p>
<p>###response.finished</p>
<p>布尔型,申明是否回复完成。开始是<code>false</code>。执行response.end()之后,值变为true。</p>
<p>###response.getHeader(name)</p>
<p>读取已经在排队当是还没有发送的header。注意,名字不区分大小写。该方法仅在header得到隐式刷新之后被调用。</p>
<p>例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var contentType = response.getHeader(&apos;content-type&apos;);</div></pre></td></tr></table></figure>
<p>###response.headersSent</p>
<p>只读,布尔型,header被发送为true,否则为false</p>
<p>###response.removeHeader(name)</p>
<p>删除队列中隐式发送的header</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response.removeHeader(&apos;Content-Encoding&apos;);</div></pre></td></tr></table></figure>
<p>###response.sendDate</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xesjiaoyan.github.io/nodejs6_cn/nodejs6_cn/2016/06/29/Http/" data-id="ciq0b4oqf0005fgfy6dc8i2gv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/nodejs6_cn/2016/06/29/Timers/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/nodejs6_cn/archives/2016/06/">June 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/nodejs6_cn/2016/06/29/Http/">(no title)</a>
          </li>
        
          <li>
            <a href="/nodejs6_cn/2016/06/29/Timers/">(no title)</a>
          </li>
        
          <li>
            <a href="/nodejs6_cn/2016/06/29/Buffer/">(no title)</a>
          </li>
        
          <li>
            <a href="/nodejs6_cn/2016/06/29/ChildProcesses/">(no title)</a>
          </li>
        
          <li>
            <a href="/nodejs6_cn/2016/06/29/Console/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Mr.zheng<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/nodejs6_cn/" class="mobile-nav-link">Home</a>
  
    <a href="/nodejs6_cn/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/nodejs6_cn/fancybox/jquery.fancybox.css">
  <script src="/nodejs6_cn/fancybox/jquery.fancybox.pack.js"></script>


<script src="/nodejs6_cn/js/script.js"></script>

  </div>
</body>
</html>